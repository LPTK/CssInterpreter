Package cssInterpreter;

Helpers
    all		 = [0 .. 0xffff];
    except_star  = [all - '*'];
    except_slash = [all - '/'];

    letter       = [['A' .. 'Z'] + ['a' .. 'z']];

    digit  	 = ['0' .. '9'];
    non_zero_digit = [digit - '0'];
    digits = digit+;

    alphanum     = letter | digit;
    id_comp      = '_' | '$';
    identifier   = (letter | id_comp) (alphanum | id_comp)*;

    character	 = [[0x20 .. 0x7e] - '"']; /* FIXME */

    cr           = 13;
    lf 	         = 10;

    star 	 = '*';


States
    normal, comment, string;


Tokens
    {normal} l_paren      = '(';
    {normal} r_paren      = ')';
    {normal} l_brace      = '{';
    {normal} r_brace      = '}';
    {normal} l_brack      = '[';
    {normal} r_brack      = ']';
    {normal} lt           = '<';
    {normal} gt           = '>';


    {normal} semicolon    = ';';

    {normal} comma	  = ',';

    {normal} dot 	  = '.';

    {normal} equal	  = '=';
    {normal} star	  = '*';

    {normal} colon	  = ':';

    {normal} blank        = (' ' | cr | lf)+;
    
    {normal} key_class    = 'class';
    {normal} key_trait    = 'trait';
    {normal} key_def    = 'def';
    {normal} key_import   = 'import';
    {normal} key_package  = 'package';
    {normal} key_parent   = 'parent';
    {normal} key_this     = 'this';

    /* Type annotation keywords */
    {normal} key_val	  = 'val';
    {normal} key_rval	  = 'rval';
    {normal} key_ref    = 'ref';

/*
    {normal} key_	  = '';
*/

    /* Nested comment management, as proposed in sablecc documentation */
    // TODO: doesn' work
    {normal->comment, comment} 
    comment_begin          = '/*';

    {comment} comment_end  = '*/'; 
    {comment} comment_body = 
    (except_star*   star   except_slash)*   star?;
    
    // // ??
    // {comment->normal} comment_end  = '*/';
    // (except_star*   star   except_slash)*   ;//star?;
    
    
    
    


    {normal->string, string->normal} 
    double_quote = '"';
    {string} string_content = character*; 

    {normal} ident          = identifier;

    integer_number = '0' | non_zero_digit digits?;

Ignored Tokens
    blank,
    comment_begin, comment_body, comment_end,
    double_quote
    ;




















Productions

/*
compilation_unit {-> closure} =
    statement*
      {-> New closure ([statement.statement])}
  ;
*/
compilation_unit {-> closure} =
    statement_list
      {-> New closure ([statement_list.statement])}
  ;


attr_type {-> attr_type} =
    {val}  key_val  {-> New attr_type.val	()}
  | {rval} key_rval {-> New attr_type.rval ()}
  | {ref}  key_ref  {-> New attr_type.ref  ()}
  ;

/*
closure {-> closure} =
    l_brace   statement*   r_brace 
      {-> New closure([statement.statement])};
*/
closure {-> closure} =
    l_brace   statement_list   r_brace 
      {-> New closure([statement_list.statement])};


/* TODO :
 / constructor_declaration 
 / destructor_declaration 
 / alias_declaration 
 / visibility_declaration 
 / attribute_declaration
 / special_declaration
 / unit_test_declaration 
 / static_initializer 
 /  ";"  . 
*/

statement_list {-> statement*} =
    first_statement?
    following_statement*
      {-> [first_statement.statement, following_statement.statement]}
    //  {-> [first_statement.statement]}
  ;

first_statement {-> statement} =
    statement {-> statement.statement}
  ;

following_statement {-> statement?} =
    semicolon statement? {-> statement.statement}
  ;

/*
    statement_list_elt*
      {-> [statement_list_elt.statement]};
statement_list_elt {-> statement} =
  | {single}
    statement {-> statement?}
  ;
*/
/*
statement {-> statement?} =
    {empty} semicolon {-> Null}
  | {expr} expression semicolon {-> New statement.expr (expression.expr)}
  | {attribute_decl} attribute_decl {-> New statement.attr_decl (attribute_decl.attr_decl)}
  | {function_decl} function_decl {-> New statement.def_decl (function_decl.def_decl)}
  ;
*/
statement {-> statement} =
    {expr} expression {-> New statement.expr (expression.expr)}
  | {attribute_decl} attribute_decl {-> New statement.attr_decl (attribute_decl.attr_decl)}
  | {function_decl} function_decl {-> New statement.def_decl (function_decl.def_decl)}
  ;


function_decl {-> def_decl} =
    
    key_def [name]:ident? [params]:param_list? [type_init]:type_init //semicolon
      {-> New def_decl (name, params.closure, type_init.typed_value)}
    
  ;


attribute_decl {-> attr_decl} =
    
    [attr_type]:attr_type? [name]:ident [type_init]:type_init //semicolon
      {-> New attr_decl (attr_type, name, type_init.typed_value)}
    
  ;


type_init {-> typed_value} =
    {explicit} colon [type]:type [assign]:assignment?
      {-> New typed_value (type, assign.expr)}
  | {inferred} colon [assign]:assignment
      {-> New typed_value (Null, assign.expr)}
  ;


assignment {-> expr} =
    equal expression
      {-> expression.expr}
  ;

/*
param_list {-> closure} =
    l_paren [statements]:statement* r_paren
      {-> New closure([statements.statement])}
  ;*/
param_list {-> closure} =
    l_paren [statements]:statement_list r_paren
      {-> New closure([statements.statement])}
  ;


type {-> type} =
    [base]:naked_type_expr [args]:template_arg_list?
      {-> New type (base.naked_type, args.expr)}
  ;

naked_type_expr {-> naked_type} =
    {ident} [name]:ident
      {-> New naked_type.ident (name)}
  | {access} [expr]:field_access
      {-> New naked_type.access (expr.field_access)}
  ;


template_arg_list {-> expr} =
    lt expression gt
    {-> expression.expr}
  ;


expression {-> expr} = 
    {single} [argxpr]:arg_expression
      {-> New expr.single (argxpr.arg_expr)}
  | {invocation} [argxpr]:arg_expression [targs]:template_arg_list? [xpr]:expression
      {-> New expr.invocation (argxpr.arg_expr, targs.expr, xpr.expr)}
  | {empty_invocation} [argxpr]:arg_expression [targs]:template_arg_list
      {-> New expr.invocation (argxpr.arg_expr, targs.expr, Null)}
  ;


arg_expression {-> arg_expr} =
    {single} [restxpr]:restricted_expression
      {-> New arg_expr.single (restxpr.restr_expr)}
  | {list} [restxpr]:restricted_expression comma [argxpr]:arg_expression
      {-> New arg_expr.list (restxpr.restr_expr, argxpr.arg_expr)}
  | {assign} [restxpr]:restricted_expression equal [argxpr]:arg_expression
      {-> New arg_expr.assign (restxpr.restr_expr, argxpr.arg_expr)}
  ;

restricted_expression {-> restr_expr} =

    {identifier} general_identifier 
      {-> New restr_expr.id (general_identifier.general_id)}
      
  | {number} integer_number
      {-> New restr_expr.number (integer_number)}

  | {field_access} field_access
      {-> New restr_expr.field_access (field_access.field_access)}
      
  | {string_expr} string_content 
      {-> New restr_expr.string (string_content)}

  | {paren_expr} l_paren   [embedded_expr]:expression   r_paren
      {-> New restr_expr.embedded(embedded_expr.expr)}
  
  | {closure} [closure]:closure
      {-> New restr_expr.closure (closure)}
  
  ;


field_access {-> field_access} =
    [prefix_expr]:restricted_expression   dot   [suffix]:ident
      {-> New field_access (prefix_expr.restr_expr, suffix)}
  ;


general_identifier {-> general_id} =
    {parent} key_parent {-> New general_id.parent ()}
  | {this} key_this {-> New general_id.this ()}
  | ident {-> New general_id.ident (ident)}
  ;










/********   AST specification   ********/
Abstract Syntax Tree

closure =
    [statements]:statement*;

attr_type = 
    {val}
  | {rval}
  | {ref}
  ;

statement = 
    {expr} expr
  | {attr_decl} attr_decl
  | {def_decl} def_decl
  ;

expr =
    {single} arg_expr
  | {invocation} [callee]:arg_expr [targs]:expr? [args]:expr?
  ;

arg_expr =
    {single} restr_expr
  | {list} restr_expr arg_expr
  | {assign} restr_expr arg_expr
  ;

restr_expr =
    {id} general_id
  | {number} integer_number
  | {field_access} field_access
  | {string} string_content
  | {closure} closure
  | {embedded} expr
  ;

attr_decl =
    [attr_type]:attr_type? [name]:ident? typed_value?
  ;
  
def_decl =
    [name]:ident? [params]:closure? typed_value?
  ;


typed_value =
    type? [value]:expr?
  ;

type =
    [base]:naked_type [args]:expr?
  ;

naked_type =
    {ident} [name]:ident
    | {access} field_access
  ;

field_access =
    [prefix_expr]:restr_expr ident
  ;


general_id =
    {parent}
  | {this} 
  | {ident} ident
  ;

