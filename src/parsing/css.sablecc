Package cssInterpreter;

Helpers
    all		 = [0 .. 0xffff];
    except_star  = [all - '*'];
    except_slash = [all - '/'];

    letter       = [['A' .. 'Z'] + ['a' .. 'z']];
    digit  	 = ['0' .. '9'];
    alphanum     = letter | digit;
    id_comp      = '_' | '$';
    identifier   = (letter | id_comp) (alphanum | id_comp)*;

    character	 = [[0x20 .. 0x7e] - '"']; /* FIXME */

    cr           = 13;
    lf 	         = 10;

    star 	 = '*';


States
    normal, comment, string;


Tokens
    {normal} l_paren      = '(';
    {normal} r_paren      = ')';
    {normal} l_brace      = '{';
    {normal} r_brace      = '}';
    {normal} l_brack      = '[';
    {normal} r_brack      = ']';
    {normal} lt           = '<';
    {normal} gt           = '>';


    {normal} semicolon    = ';';

    {normal} comma	  = ',';

    {normal} dot 	  = '.';

    {normal} equal	  = '=';
    {normal} star	  = '*';

    {normal} colon	  = ':';

    {normal} blank        = (' ' | cr | lf)+;
    
    {normal} key_class    = 'class';
    {normal} key_import   = 'import';
    {normal} key_package  = 'package';
    {normal} key_parent   = 'parent';
    {normal} key_this     = 'this';

    /* Type keywords 
    {normal} key_bool	  = 'bool';
    {normal} key_char	  = 'char';
    {normal} key_int	  = 'int';*/

    /* Type annotation keywords */
    {normal} key_val	  = 'val';
    {normal} key_rval	  = 'rval';
    {normal} key_ref    = 'ref';
    {normal} key_def    = 'def';

/*
    {normal} key_	  = '';
*/

    /* Nested comment management, as proposed in sablecc documentation */
    {normal->comment, comment} 
    comment_begin          = '/*';

    {comment} comment_end  = '*/'; 
    {comment} comment_body = 
    (except_star*   star   except_slash)*   star?;


    {normal->string, string->normal} 
    double_quote = '"';
    {string} string_content = character*; 

    {normal} ident          = identifier;

Ignored Tokens
    blank,
    comment_begin, comment_body, comment_end,
    double_quote
    ;




















Productions



/*
compilation_unit {-> compilation_unit} =
    statement*
      {-> New compilation_unit ([statement.statement])};
*/

compilation_unit {-> closure} =
    statement*
      {-> New closure ([statement.statement])}
  ;

/*
full_type {-> full_type} =
    {type_name} [type]:type_name 
      {-> New full_type.type_name (type.ident)}
*/
/*    {primitive} [type]:primitive_type 
      {-> New full_type.primitive (type.primitive_type)}*/
/*
  | {type_expr} type_expr
  | {full_composed} full_composed_type
*/

/*
primitive_type =
    {bool} key_bool {-> New primitive_type.bool ()}
  | {char} key_char {-> New primitive_type.char ()}
  | {int}  key_int  {-> New primitive_type.int 	()}
  ;
*/

attr_type {-> attr_type} =
    {val}  key_val  {-> New attr_type.val	()}
  | {rval} key_rval {-> New attr_type.rval ()}
  | {ref}  key_ref  {-> New attr_type.ref  ()}
//  | {def}  key_def  {-> New field_type.def  ()}
  ;


closure {-> closure} =
    l_brace   statement*   r_brace 
      {-> New closure([statement.statement])};

/*
field_declaration {-> field?} =
    {method_declaration} method_declaration 
      {-> New field_declaration.method_declaration (method_declaration.method_declaration)}
  | {empty} semicolon {-> Null}
  ;*/
/* TODO :
 / constructor_declaration 
 / destructor_declaration 
 / alias_declaration 
 / visibility_declaration 
 / attribute_declaration
 / special_declaration
 / unit_test_declaration 
 / static_initializer 
 /  ";"  . 
*/

/*
method_declaration {-> method_declaration} =
    key_class?   key_def   [name]:ident
    [type]:type_annotation?
    [body]:block_or_empty
      {-> New method_declaration (name, type, [body.statement])}
  ;*/
/* TODO : full syntax */


/* FIXME : method_type_annotation rather ? 
type_annotation {-> type_annotation} =
    colon   [attribute]:attribute_type   [type]:full_type
      {-> New type_annotation (attribute, type.full_type)};
*/

/*
block_or_empty {-> statement*} =
    {empty} semicolon {-> []}
  | {block} statement_block {-> [statement_block.statement]}
  ;

statement_block {-> statement*} =
    l_brace   statement*   r_brace {-> [statement.statement]};
*/



statement {-> statement?} =
    {empty} semicolon {-> Null}
  | {expr} expression semicolon {-> New statement.expr (expression.expr)}
  | {attribute_decl} attribute_decl {-> New statement.attr_decl (attribute_decl.attr_decl)}
  | {function_decl} function_decl {-> New statement.def_decl (function_decl.def_decl)}
  ;


/*
attribute_decl {-> decl} =
    
    // {named_decl} [decl_type]:field_type? [name]:ident [params]:param_list? [type_init]:type_init? [clos]:decl_end
    // //  {-> New decl (decl_type, name, params.closure, type_init.type, type_init.value)}
    //   {-> New decl (decl_type, name, params.closure, type_init.typed_value, clos.closure)}
    
    
    {named_decl} [decl_type]:field_type? [name]:ident [type_init]:type_init [clos]:decl_end
    //  {-> New decl (decl_type, name, params.closure, type_init.type, type_init.value)}
      {-> New decl (decl_type, name, Null, type_init.typed_value, clos.closure)}
    
  | {typed_decl} [decl_type]:field_type [params]:param_list? [type_init]:type_init [clos]:decl_end
      {-> New decl (decl_type, Null, params.closure, type_init.typed_value, clos.closure)}
    
  ;
*/
  
// declaration {-> decl} =
    
//     {named_decl} [decl_type]:field_type [name]:ident [type_init]:type_init [clos]:decl_end
//       {-> New decl (decl_type, name, Null, type_init.typed_value, clos.closure)}
    
//   ;

function_decl {-> def_decl} =
    
    key_def [name]:ident? [params]:param_list? [type_init]:type_init semicolon
      {-> New def_decl (name, params.closure, type_init.typed_value)}
    
  ;


attribute_decl {-> attr_decl} =
    
    [attr_type]:attr_type? [name]:ident [type_init]:type_init semicolon
    //  {-> New decl (decl_type, name, params.closure, type_init.type, type_init.value)}
      {-> New attr_decl (attr_type, name, type_init.typed_value)}
    
  ;




type_init {-> typed_value} =
    {explicit} colon [type]:type [assign]:assignment?
      {-> New typed_value (type, assign.expr)}
  | {inferred} colon [assign]:assignment
      {-> New typed_value (Null, assign.expr)}
  ;
/*
type_init {-> type, expr} =
    {explicit} colon [type]:type [assign]:assignment?
      {-> type, assign.expr}
  | {inferred} colon [assign]:assignment
      {-> Null, assign.expr}
  ;
*/










/*
decl_end {-> closure} =
    semicolon
    {-> Null}
  | [closure]:closure
    {-> New closure(closure.closure)}
  ;
*/
decl_end {-> closure?} =
    //l_brack /////// semicolon
    semicolon
    {-> Null}
  ;








assignment {-> expr} =
    equal expression
      {-> expression.expr}
  ;

param_list {-> closure} =
    l_paren [statements]:statement* r_paren
      {-> New closure([statements.statement])}
  ;


/*
type_spec {-> type} =
    colon [type]:type
      {-> type.type}
   ;
*/

type {-> type} =
    [base]:naked_type_expr [args]:template_arg_list?
      {-> New type (base.naked_type, args.expr)}
  ;

naked_type_expr {-> naked_type} =
    {ident} [name]:ident
      {-> New naked_type.ident (name)}
  | {access} [expr]:field_access
      //{-> New naked_type.access (expr.prefix_expr, expr.ident)}
      {-> New naked_type.access (expr.field_access)}
  ;
  
  
/*
template_arg_list {-> arg_list} =
    lt arg_list gt
    {-> arg_list.arg_list}
  ;
*/
template_arg_list {-> expr} =
    lt expression gt
    {-> expression.expr}
  ;







// expression {-> expr} =
//     {identifier} general_identifier 
//       {-> New expr.id (general_identifier.general_id)}
//   | {invocation} invocation
//       {-> New expr.invocation (invocation)}
//   /* Ident on the right, do we keep it ? */
//   /*| {field_access} [prefix_expr]:expression   dot   [suffix]:ident
//       {-> New expr.field_access (prefix_expr.expr, suffix)}*/
//   | {field_access} field_access
//       {-> New expr.field_access (field_access.field_access)}
//   | {string_expr} string_content 
//       {-> New expr.string (string_content)}
//   /*| {paren_expr} l_paren   [embedded_expr]:expression   r_paren 
//       {-> New expr (embedded_expr.expr)}*/
//     | {paren_expr} l_paren   [embedded_expr]:expression   r_paren 
//       {-> embedded_expr.expr}
//   | {closure} [closure]:closure
//       {-> New expr.closure (closure)}
//   ;




expression {-> expr} = 
    {single} [argxpr]:arg_expression
      {-> New expr.single (argxpr.arg_expr)}
  | {invocation} [restxpr]:restricted_expression [xpr]:expression //arg_list
  //| {invocation} [restxpr]:restricted_expression [a]:star [b]:star [xpr]:expression //arg_list
      {-> New expr.invocation (restxpr.restr_expr, xpr.expr)}
  ;


arg_expression {-> arg_expr} =
    {single} [restxpr]:restricted_expression
      {-> New arg_expr.single (restxpr.restr_expr)}
  | {list} [restxpr]:restricted_expression comma [argxpr]:arg_expression
      {-> New arg_expr.list (restxpr.restr_expr, argxpr.arg_expr)}
  ;

restricted_expression {-> restr_expr} =

    {identifier} general_identifier 
      {-> New restr_expr.id (general_identifier.general_id)}
      
  | {field_access} field_access
      {-> New restr_expr.field_access (field_access.field_access)}
      
  | {string_expr} string_content 
      {-> New restr_expr.string (string_content)}
      
      
  /*| {invocation} invocation
      {-> New expr.invocation (invocation)} */
  /*| {paren_expr} l_paren   [embedded_expr]:expression   r_paren
      {-> embedded_expr.restr_expr}*/
      
  | {paren_expr} l_paren   [embedded_expr]:expression   r_paren
      {-> New restr_expr.embedded(embedded_expr.expr)}
  
  | {closure} [closure]:closure
      {-> New restr_expr.closure (closure)}
  
  /*
  | {list} [arg_list]:arg_list
      {-> New restr_expr.arg_list (arg_list)}
      */
  
  ;









/*
field_access {-> field_access} =
    [prefix_expr]:expression   dot   [suffix]:ident
      {-> New field_access (prefix_expr.expr, suffix)}
  ;
*/
field_access {-> field_access} =
    [prefix_expr]:restricted_expression   dot   [suffix]:ident
      {-> New field_access (prefix_expr.restr_expr, suffix)}
  ;
  
  
  
  
  
  
  
  
  

/*
invocation {-> invocation} =
    expression   l_brack  arg_list  r_brack
      {-> New invocation (expression.expr, arg_list.arg_list)}
  ;
*/


/*        Method call and arguments        */
// arg_list {-> arg_list} =
//     arg   [tail]:arg_list_tail* 
//       {-> New arg_list ([arg, tail.arg])};
// /*    {empty} {-> New arg_list ([])}
//   | {not_empty} arg   [tail]:arg_list_tail* 
//       {-> New arg_list ([arg, tail.arg])};*/

// arg_list_tail {-> arg } =
//     comma arg  {-> arg};

// arg =
//     /* TODO : ident, sure ? */
//     {assign} ident   equal   expression 
//       {-> New arg.assign (ident, expression.expr)}
//   | {expression} expression {-> New arg.expr (expression.expr)}
//   ;


// arg_list {-> arg_list} =
//     arg   [tail]:arg_list_tail+ ////////////////// gère pas le sinlge arg 
//       {-> New arg_list ([arg, tail.arg])};
// /*    {empty} {-> New arg_list ([])}
//   | {not_empty} arg   [tail]:arg_list_tail* 
//       {-> New arg_list ([arg, tail.arg])};*/

// arg_list_tail {-> arg } =
//     comma arg  {-> arg};

// arg =
//     /* TODO : ident, sure ? */
//     {assign} ident   equal   arg_list_expression 
//       {-> New arg.assign (ident, arg_list_expression.restr_expr)}
//   | {expression} restricted_expression {-> New arg.expr (restricted_expression.restr_expr)}
//   ;










general_identifier {-> general_id} =
    {parent} key_parent {-> New general_id.parent ()}
  | {this} key_this {-> New general_id.this ()}
  | ident {-> New general_id.ident (ident)}
  ;





















/********   AST specification   ********/
Abstract Syntax Tree

/*
compilation_unit =
    [statements]:statement*;
*/

closure =
    [statements]:statement*;

/*
field =
    {instruction} instruction
  | {declaration}
;

instruction =
    {call_statement} [called_expr]:ident

expression =



full_type =
    {type_name} ident
//    {primitive} primitive_type
// TODO 
  ;
*/

/*
primitive_type =
    {bool}
  | {char}
  | {int}
  ;
*/

attr_type = 
    {val}
  | {rval}
  | {ref}
 // | {def}
  ;

/*
type_declaration = 
    {class_declaration} class_declaration;


class_declaration =
    [class_name]:ident   [block]:field_declaration*;


field_declaration =
    {method_declaration} method_declaration
  ;

method_declaration =
    [name]:ident   [type]:type_annotation?   [block]:statement*
  ;
*/
/*
type_annotation =
    attribute_type?   full_type
  ;
*/
  
statement = 
    {expr} expr
  | {attr_decl} attr_decl
  | {def_decl} def_decl
  ;

expr =
    {single} arg_expr
  | {invocation} restr_expr expr
  ;

arg_expr =
    {single} restr_expr
  | {list} restr_expr arg_expr
  ;

restr_expr =
    {id} general_id
  //| {invocation} invocation
  //| {field_access} [prefix_expr]:expr   [suffix]:ident
  | {field_access} field_access
  | {string} string_content
  | {closure} closure
  | {arg_list} arg_list
  | {embedded} expr
  ;
/*
decl =
    [field_type]:field_type? [name]:ident? [params]:closure? type? [value]:expr?
  ;
*/
attr_decl =
    [attr_type]:attr_type? [name]:ident? typed_value?
  ;
  
def_decl =
    [name]:ident? [params]:closure? typed_value?
  ;


typed_value =
    type? [value]:expr?
  ;

/*
type =
    [base]:naked_type [args]:arg_list?
  ;*/
type =
    [base]:naked_type [args]:expr?
  ;

naked_type =
    {ident} [name]:ident
  //| {access} [expr]:expr [name]:ident
    | {access} field_access
  ;




/*
field_access =
    [prefix_expr]:expr ident
  ;
*/
field_access =
    [prefix_expr]:restr_expr ident
  ;





/* FIXME : maybe having a rule here is useless
   (can be directly in the expr "invocation" rule...) */
invocation =
    expr   arg_list
  ;

arg_list =
    arg*
  ;

/*
arg =
    {assign} ident   expr ///// TODO : ident, sure ?
  | {expr} expr
  ;
*/
arg =
    {assign} ident   restr_expr /* TODO : ident, sure ? */
  | {expr} restr_expr
  ;





general_id =
    {parent}
  | {this} 
  | {ident} ident
  ;
