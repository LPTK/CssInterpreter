Package cssInterpreter;

Helpers
    all		 = [0 .. 0xffff];
    except_star  = [all - '*'];
    except_slash = [all - '/'];

    letter       = [['A' .. 'Z'] + ['a' .. 'z']];
    digit  	 = ['0' .. '9'];
    alphanum     = letter | digit;
    id_comp      = '_' | '$';
    identifier   = (letter | id_comp) (alphanum | id_comp)*;

    character	 = [[0x20 .. 0x7e] - '"']; /* FIXME */

    cr           = 13;
    lf 	         = 10;

    star 	 = '*';


States
    normal, comment, string;


Tokens
    {normal} l_paren      = '(';
    {normal} r_paren      = ')';
    {normal} l_brace      = '{';
    {normal} r_brace      = '}';
    {normal} l_brack      = '[';
    {normal} r_brack      = ']';


    {normal} semicolon    = ';';

    {normal} comma	  = ',';

    {normal} dot 	  = '.';

    {normal} equal	  = '=';
    {normal} star	  = '*';

    {normal} colon	  = ':';

    {normal} blank        = (' ' | cr | lf)+;
    
    {normal} key_class    = 'class';
    {normal} key_def	  = 'def';
    {normal} key_import   = 'import';
    {normal} key_package  = 'package';
    {normal} key_parent   = 'parent';
    {normal} key_this     = 'this';

    /* Type keywords */
    {normal} key_bool	  = 'bool';
    {normal} key_char	  = 'char';
    {normal} key_int	  = 'int';

    /* Type annotation keywords */
    {normal} key_val	  = 'val';
    {normal} key_rval	  = 'rval';
    {normal} key_ref	  = 'ref';

/*
    {normal} key_	  = '';
*/

    /* Nested comment management, as proposed in sablecc documentation */
    {normal->comment, comment} 
    comment_begin          = '/*';

    {comment} comment_end  = '*/'; 
    {comment} comment_body = 
    (except_star*   star   except_slash)*   star?;


    {normal->string, string->normal} 
    double_quote = '"';
    {string} string_content = character*; 

    {normal} ident          = identifier;

Ignored Tokens
    blank,
    comment_begin, comment_body, comment_end,
    double_quote
    ;




Productions
compilation_unit {-> compilation_unit} = 
    package_statement   import_statement*   type_declaration*
      {-> New compilation_unit 
            (package_statement.package_statement, [import_statement.import_statement],
             [type_declaration.type_declaration])};


package_statement {-> package_statement} = 
    key_package   package_name   semicolon 
      {-> New package_statement (package_name)};

import_statement {-> import_statement} =
    key_import   package_import_path   semicolon
      {-> New import_statement (package_import_path)};

/* 
 * Grammar transform to support the 
 * import <qualified package name>.*;
 * syntax. 
 */
package_import_path {-> package_import_path} =
    [prefix]:package_import_prefix*   import_type;

package_import_prefix =
    ident   dot {-> New package_import_prefix (ident)};

import_type {-> import_type} =
    {full_package} star {-> New import_type.full_package ()	}
  | {single_type} ident {-> New import_type.single_type  (ident)}
  ;

package_name {-> package_name} =
    ident   [tail]:pkg_name_tail* {-> New package_name ([ident, tail.ident])};

pkg_name_tail {-> ident } =
    dot   ident  {-> ident};


type_name = 
    {ident} ident
/*  | {pkg_name} package_name   dot   ident */ /* TODO */
/*  | {full_type} full_type   dot   ident  */ /* TODO */
  ;


/* TODO */
full_type {-> full_type} =
    {primitive} [type]:primitive_type 
      {-> New full_type.primitive (type.primitive_type)}
/*
  | {type_expr} type_expr
  | {full_composed} full_composed_type
*/
  ;


primitive_type =
    {bool} key_bool {-> New primitive_type.bool ()}
  | {char} key_char {-> New primitive_type.char ()}
  | {int}  key_int  {-> New primitive_type.int 	()}
  ;


type_attribute {-> type_attribute} =
    {val}  key_val  {-> New type_attribute.val	()}
  | {rval} key_rval {-> New type_attribute.rval ()}
  | {ref}  key_ref  {-> New type_attribute.ref 	()}
  ;


type_declaration {-> type_declaration} = 
    {class_declaration} class_declaration 
      {-> New type_declaration.class_declaration (class_declaration.class_declaration)}
/* TODO : others (interface / typedef) */
  ;

class_declaration {-> class_declaration} =
    key_class   [name]:ident
    /* TODO : template inheritage visibility annotations */
    [block]:field_block
      {-> New class_declaration (name, [block.field_declaration])}
;


field_block {-> field_declaration*} =
    l_brace   field_declaration*   r_brace 
      {-> [field_declaration.field_declaration]};


field_declaration {-> field_declaration?} =
    {method_declaration} method_declaration 
      {-> New field_declaration.method_declaration (method_declaration.method_declaration)}
  | {empty} semicolon {-> Null}
  ;
/* TODO :
 / constructor_declaration 
 / destructor_declaration 
 / alias_declaration 
 / visibility_declaration 
 / attribute_declaration
 / special_declaration
 / unit_test_declaration 
 / static_initializer 
 /  ";"  . 
*/


method_declaration {-> method_declaration} =
    key_class?   key_def   [name]:ident
    [type]:type_annotation?
    [body]:block_or_empty
      {-> New method_declaration (name, type, [body.statement])}
  ;
/* TODO : full syntax */


/* FIXME : method_type_annotation rather ? */
type_annotation {-> type_annotation} =
    colon   [attribute]:type_attribute   [type]:full_type
      {-> New type_annotation (attribute, type.full_type)};

block_or_empty {-> statement*} =
    {empty} semicolon {-> []}
  | {block} statement_block {-> [statement_block.statement]}
  ;

statement_block {-> statement*} =
    l_brace   statement*   r_brace {-> [statement.statement]};


statement {-> statement?} =
    {empty} semicolon {-> Null}
  | {expr} expression {-> New statement.expr (expression.expr)}
  ;


expression {-> expr} =
    {identifier} general_identifier 
      {-> New expr.id (general_identifier.general_id)}
  | {method_call} method_call {-> New expr.method_call (method_call)}
  /* Ident on the right, do we keep it ? */
  | {reference} [prefix_expr]:expression   dot   [suffix]:ident
      {-> New expr.reference (prefix_expr.expr, suffix)}
  | {string_expr} string_content 
      {-> New expr.string (string_content)}
  ;



/*        Method call and arguments        */
method_call {-> method_call} =
    expression   l_paren   arg_list   r_paren
      {-> New method_call (expression.expr, arg_list.arg_list)}
  ;

arg_list {-> arg_list} =
    {empty} {-> New arg_list ([])}
  | {not_empty} arg   [tail]:arg_list_tail* 
      {-> New arg_list ([arg, tail.arg])};

arg_list_tail {-> arg } =
    comma arg  {-> arg};

arg =
    /* TODO : ident, sure ? */
    {assign} ident   equal   expression 
      {-> New arg.assign (ident, expression.expr)}
  | {expression} expression {-> New arg.expr (expression.expr)}
  ;




general_identifier {-> general_id} =
    {parent} key_parent {-> New general_id.parent ()}
  | {this} key_this {-> New general_id.this ()}
  | ident {-> New general_id.ident (ident)}
  ;



/********   AST specification   ********/
Abstract Syntax Tree
compilation_unit  = 
    package_statement   import_statement*   type_declaration*;


package_statement  = 
    package_name;

package_name =
    [components]:ident+;


import_statement  =
    package_import_path;

package_import_path =
    [prefix]:package_import_prefix*   import_type;

package_import_prefix =
    ident;

import_type =
    {full_package}
  | {single_type} ident
  ;


full_type =
    {primitive} primitive_type
/* TODO */
  ; 

primitive_type =
    {bool}
  | {char}
  | {int}
  ;


type_attribute = 
    {val}
  | {rval}
  | {ref}
  ;


type_declaration = 
    {class_declaration} class_declaration;


class_declaration =
    [class_name]:ident   [block]:field_declaration*;


field_declaration =
    {method_declaration} method_declaration
  ;

method_declaration =
    [name]:ident   [type]:type_annotation?   [block]:statement*
  ;


type_annotation =
    type_attribute?   full_type
  ;

statement = 
    {expr} expr
  ;

expr =
    {id} general_id
  | {method_call} method_call
  | {reference} [prefix_expr]:expr   [suffix]:ident
  | {string} string_content
  ;


/* FIXME : maybe having a rule here is useless
   (can be directly in the expr "method_call" rule...) */
method_call =
    expr   arg_list;


arg_list =
    arg*;

arg =
    {assign} ident   expr /* TODO : ident, sure ? */
  | {expr} expr
  ;


general_id =
    {parent}
  | {this} 
  | {ident} ident
  ;
